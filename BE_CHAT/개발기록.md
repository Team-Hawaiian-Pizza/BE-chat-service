# 개발 기록

## 2025-08-12

### 초기 설정
- 개발 기록을 위한 MD 파일 생성
- 앞으로 구현하는 모든 기능과 변경사항을 이 파일에 기록 예정

### MSA 아키텍처 기반 1대1 채팅 서비스 구현

---

## 🏗️ 1. 프로젝트 구조 및 아키텍처 설계

### MSA 서비스 설계
```
core-service (소유)
├── User, Profile, AuthToken 모델
├── 외부 제공: GET /users/{id}, JWKS
└── 이벤트: user.created

chat-service (소유) ← 현재 구현 중
├── Conversation, Message, DeliveryReceipt 모델
├── 외부 제공: GET /conversations/{id}
├── 이벤트: message.created
└── 외부 참조: user_id (core의 ID, FK 아님)

ai-service (소유)  
├── AiJob, Prompt, AiResponse, Embedding 모델
├── 외부 제공: POST /ai/jobs
├── 이벤트: ai.message.generated
└── 외부 참조: message_id (chat의 ID, FK 아님)
```

### Django 앱 생성
```bash
python manage.py startapp chat
```

**설계 원칙:**
- 서비스 간 느슨한 결합 (Loose Coupling)
- 데이터베이스 분리 (Database per Service)
- 이벤트 드리븐 아키텍처 (Event-Driven Architecture)
- API 기반 통신

---

## 🗄️ 2. 데이터베이스 모델 설계 (MySQL)

### 파일: `chat/models.py`

#### Conversation 모델
```python
class Conversation(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    participant1_id = models.CharField(max_length=255, db_index=True)  # core-service 참조
    participant2_id = models.CharField(max_length=255, db_index=True)  # core-service 참조
    created_at = models.DateTimeField(default=timezone.now)
    updated_at = models.DateTimeField(auto_now=True)
    is_active = models.BooleanField(default=True)
```

**특징:**
- UUID 기반 Primary Key (분산 환경에서 충돌 방지)
- participant_id는 core-service의 user_id 참조 (FK 아님, MSA 원칙)
- unique_together 제약으로 중복 대화방 방지
- 인덱스 최적화: (participant1_id, participant2_id), created_at

#### Message 모델
```python
class Message(models.Model):
    MESSAGE_TYPES = [
        ('text', 'Text'),
        ('image', 'Image'), 
        ('file', 'File'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    conversation = models.ForeignKey(Conversation, on_delete=models.CASCADE, related_name='messages')
    sender_id = models.CharField(max_length=255, db_index=True)  # core-service 참조
    content = models.TextField()
    message_type = models.CharField(max_length=10, choices=MESSAGE_TYPES, default='text')
    created_at = models.DateTimeField(default=timezone.now)
    updated_at = models.DateTimeField(auto_now=True)
    is_deleted = models.BooleanField(default=False)  # 소프트 삭제
```

**특징:**
- 다양한 메시지 타입 지원 (텍스트, 이미지, 파일)
- 소프트 삭제 구현 (is_deleted 플래그)
- 인덱스 최적화: (conversation, created_at), sender_id

#### DeliveryReceipt 모델
```python
class DeliveryReceipt(models.Model):
    DELIVERY_STATUS = [
        ('sent', 'Sent'),
        ('delivered', 'Delivered'),
        ('read', 'Read'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    message = models.ForeignKey(Message, on_delete=models.CASCADE, related_name='delivery_receipts')
    user_id = models.CharField(max_length=255, db_index=True)  # core-service 참조
    status = models.CharField(max_length=10, choices=DELIVERY_STATUS, default='sent')
    timestamp = models.DateTimeField(default=timezone.now)
```

**특징:**
- 메시지 전달 상태 추적 (전송됨, 전달됨, 읽음)
- unique_together 제약: (message, user_id)
- 인덱스 최적화: (message, user_id), (user_id, status)

---

## 🔧 3. Django 설정 업데이트

### 파일: `BE_CHAT/settings.py`

#### INSTALLED_APPS 추가
```python
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',      # 새로 추가
    'channels',           # 새로 추가 (WebSocket)
    'chat',              # 새로 추가 (채팅 앱)
]
```

#### MySQL 데이터베이스 설정
```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'chat_db',
        'USER': 'root',
        'PASSWORD': 'password',
        'HOST': 'localhost',
        'PORT': '3306',
        'OPTIONS': {
            'charset': 'utf8mb4',  # 이모지 지원
        },
    }
}
```

#### Django Channels 설정
```python
ASGI_APPLICATION = 'BE_CHAT.asgi.application'

CHANNEL_LAYERS = {
    'default': {
        'BACKEND': 'channels_redis.core.RedisChannelLayer',
        'CONFIG': {
            "hosts": [('127.0.0.1', 6379)],
        },
    },
}
```

#### DRF 설정
```python
REST_FRAMEWORK = {
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 20
}
```

#### 기타 설정
```python
TIME_ZONE = 'Asia/Seoul'  # 한국 시간대
```

---

## 📡 4. REST API 엔드포인트 구현

### 파일: `chat/serializers.py`

#### MessageSerializer
```python
class MessageSerializer(serializers.ModelSerializer):
    class Meta:
        model = Message
        fields = ['id', 'sender_id', 'content', 'message_type', 'created_at', 'updated_at', 'is_deleted']
        read_only_fields = ['id', 'created_at', 'updated_at']
```

#### ConversationSerializer
```python
class ConversationSerializer(serializers.ModelSerializer):
    messages = MessageSerializer(many=True, read_only=True)
    last_message = serializers.SerializerMethodField()
    
    class Meta:
        model = Conversation
        fields = ['id', 'participant1_id', 'participant2_id', 'created_at', 'updated_at', 'is_active', 'messages', 'last_message']
        read_only_fields = ['id', 'created_at', 'updated_at']
    
    def get_last_message(self, obj):
        last_message = obj.messages.filter(is_deleted=False).order_by('-created_at').first()
        if last_message:
            return MessageSerializer(last_message).data
        return None
```

### 파일: `chat/views.py`

#### MSA 외부 제공 API
```python
class ConversationDetailView(generics.RetrieveAPIView):
    """특정 대화방 조회 - MSA 외부 제공 API"""
    queryset = Conversation.objects.all()
    serializer_class = ConversationSerializer
    lookup_field = 'id'
```

#### 내부 API 엔드포인트들
1. **사용자 대화방 목록 조회**
```python
@api_view(['GET'])
def user_conversations(request, user_id):
    conversations = Conversation.objects.filter(
        Q(participant1_id=user_id) | Q(participant2_id=user_id),
        is_active=True
    ).order_by('-updated_at')
```

2. **대화방 생성 (중복 방지 로직 포함)**
```python
@api_view(['POST'])
def create_conversation(request):
    # 이미 존재하는 대화방인지 확인
    existing_conversation = Conversation.objects.filter(
        Q(participant1_id=participant1_id, participant2_id=participant2_id) |
        Q(participant1_id=participant2_id, participant2_id=participant1_id)
    ).first()
```

3. **메시지 전송 (이벤트 발행 포함)**
```python
@api_view(['POST'])
def send_message(request, conversation_id):
    if serializer.is_valid():
        message = serializer.save(conversation=conversation)
        
        # 메시지 생성 이벤트 발행
        publish_message_created_event(message)
```

### 파일: `chat/urls.py`
```python
urlpatterns = [
    # MSA 외부 제공 API
    path('conversations/<uuid:id>/', views.ConversationDetailView.as_view(), name='conversation-detail'),
    
    # 내부 API
    path('users/<str:user_id>/conversations/', views.user_conversations, name='user-conversations'),
    path('conversations/', views.create_conversation, name='create-conversation'),
    path('conversations/<uuid:conversation_id>/messages/', views.conversation_messages, name='conversation-messages'),
    path('conversations/<uuid:conversation_id>/messages/send/', views.send_message, name='send-message'),
    path('messages/<uuid:message_id>/read/', views.mark_message_as_read, name='mark-message-read'),
]
```

---

## 🔌 5. 실시간 채팅을 위한 WebSocket 구현

### 파일: `chat/consumers.py`

#### ChatConsumer 클래스
```python
class ChatConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        self.conversation_id = self.scope['url_route']['kwargs']['conversation_id']
        self.conversation_group_name = f'chat_{self.conversation_id}'
        
        # 대화방 존재 여부 확인
        conversation = await self.get_conversation(self.conversation_id)
        if not conversation:
            await self.close()
            return
        
        # 그룹에 참여
        await self.channel_layer.group_add(
            self.conversation_group_name,
            self.channel_name
        )
        
        await self.accept()
        await self.send_conversation_history()  # 연결 시 기존 메시지 전송
```

#### 메시지 처리 로직
```python
async def receive(self, text_data):
    text_data_json = json.loads(text_data)
    message_type = text_data_json.get('type')
    
    if message_type == 'chat_message':
        await self.handle_chat_message(text_data_json)
    elif message_type == 'mark_as_read':
        await self.handle_mark_as_read(text_data_json)
    elif message_type == 'typing':
        await self.handle_typing(text_data_json)
```

#### 주요 기능들
1. **실시간 메시지 송수신**
   - 그룹 기반 브로드캐스팅
   - 메시지 DB 저장 후 그룹 전체에 전송

2. **타이핑 상태 표시**
   - 다른 참가자에게 타이핑 상태 실시간 전송

3. **메시지 읽음 확인**
   - 읽음 상태 업데이트 및 그룹 알림

4. **연결 관리**
   - 연결/해제 시 그룹 참여/탈퇴
   - 에러 처리 및 유효성 검사

### 파일: `chat/routing.py`
```python
websocket_urlpatterns = [
    path('ws/chat/<uuid:conversation_id>/', consumers.ChatConsumer.as_asgi()),
]
```

### 파일: `BE_CHAT/asgi.py`
```python
application = ProtocolTypeRouter({
    "http": get_asgi_application(),
    "websocket": AuthMiddlewareStack(
        URLRouter(
            websocket_urlpatterns
        )
    ),
})
```

---

## 📨 6. 이벤트 발행 시스템

### 파일: `chat/events.py`

#### message.created 이벤트
```python
def publish_message_created_event(message):
    event_data = {
        'event_type': 'message.created',
        'timestamp': datetime.now().isoformat(),
        'data': {
            'message_id': str(message.id),
            'conversation_id': str(message.conversation.id),
            'sender_id': message.sender_id,
            'content': message.content,
            'message_type': message.message_type,
            'created_at': message.created_at.isoformat(),
        }
    }
    
    # 현재는 로깅으로 구현 (추후 RabbitMQ/Kafka 연동)
    logger.info(f"Publishing event: {json.dumps(event_data, indent=2)}")
```

**MSA 이벤트 설계:**
- 표준 이벤트 스키마 (event_type, timestamp, data)
- JSON 직렬화 가능한 형태
- 추후 메시지 브로커 연동 준비

---

## 📦 7. 패키지 의존성

### 파일: `requirements.txt`
```
Django==5.2.5
djangorestframework==3.15.2
channels==4.1.0
channels-redis==4.2.0
mysqlclient==2.2.4
redis==5.0.8
```

**주요 패키지 설명:**
- **Django**: 웹 프레임워크
- **djangorestframework**: REST API 구현
- **channels**: WebSocket 지원
- **channels-redis**: Redis 기반 채널 레이어
- **mysqlclient**: MySQL 연동
- **redis**: 캐싱 및 채널 레이어

---

## 🚀 8. 배포 및 실행 가이드

### 환경 설정
1. **가상환경 생성**
```bash
python -m venv venv
source venv/bin/activate  # Linux/Mac
```

2. **패키지 설치**
```bash
pip install -r requirements.txt
```

3. **데이터베이스 설정**
```bash
# MySQL 데이터베이스 생성
CREATE DATABASE chat_db CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

# 마이그레이션
python manage.py makemigrations
python manage.py migrate
```

4. **Redis 서버 실행**
```bash
redis-server
```

5. **Django 서버 실행**
```bash
python manage.py runserver
```

### API 사용 예시

#### 대화방 생성
```bash
curl -X POST http://localhost:8000/api/chat/conversations/ \
  -H "Content-Type: application/json" \
  -d '{"participant1_id": "user1", "participant2_id": "user2"}'
```

#### WebSocket 연결
```javascript
const socket = new WebSocket('ws://localhost:8000/ws/chat/CONVERSATION_ID/');

// 메시지 전송
socket.send(JSON.stringify({
    'type': 'chat_message',
    'sender_id': 'user1',
    'content': '안녕하세요!',
    'message_type': 'text'
}));
```

---

## ✅ 9. 구현된 주요 기능

### 핵심 기능
- ✅ **1대1 대화방 생성 및 관리**
  - 중복 대화방 방지 로직
  - participant 기반 대화방 검색
  
- ✅ **실시간 메시지 송수신 (WebSocket)**
  - Django Channels 기반 구현
  - 그룹 브로드캐스팅
  - 연결 시 대화 히스토리 자동 전송

- ✅ **메시지 읽음 확인 시스템**
  - DeliveryReceipt 모델 활용
  - 상태별 추적 (sent, delivered, read)
  - 실시간 읽음 상태 동기화

- ✅ **타이핑 상태 표시**
  - WebSocket 기반 실시간 알림
  - 다른 참가자에게 타이핑 상태 전달

- ✅ **이벤트 기반 아키텍처**
  - message.created 이벤트 발행
  - 추후 메시지 브로커 연동 준비
  - JSON 스키마 표준화

- ✅ **MSA 호환 API 설계**
  - 외부 제공 API 분리
  - 느슨한 결합 구조
  - user_id 참조 (FK 미사용)

- ✅ **데이터베이스 최적화**
  - UUID 기반 PK
  - 인덱스 최적화
  - 소프트 삭제 구현

### 성능 최적화
- ✅ **인덱스 전략**
  - participant 조합 인덱스
  - 시간 기반 정렬 인덱스
  - 상태별 검색 인덱스

- ✅ **쿼리 최적화**
  - related_name 활용
  - 필터링 최적화
  - 페이지네이션 적용

---

## 🔮 10. 추후 개선 사항

### 인프라 개선
- [ ] **메시지 브로커 연동**
  - RabbitMQ 또는 Apache Kafka 도입
  - 이벤트 발행 실패 시 재시도 로직
  - 이벤트 스키마 검증

- [ ] **캐싱 전략**
  - Redis를 활용한 대화방 목록 캐싱
  - 최근 메시지 캐싱
  - 사용자 온라인 상태 캐싱

### 기능 확장
- [ ] **파일 업로드**
  - AWS S3 연동
  - 이미지/동영상 미리보기
  - 파일 크기 제한 및 검증

- [ ] **메시지 암호화**
  - End-to-End 암호화
  - 키 교환 프로토콜
  - 보안 감사 로그

- [ ] **푸시 알림**
  - FCM 연동
  - 웹 푸시 알림
  - 알림 설정 관리

- [ ] **고급 기능**
  - 메시지 검색 (Elasticsearch)
  - 메시지 번역
  - 스팸 필터링
  - 메시지 예약 전송

### 모니터링 & 로깅
- [ ] **성능 모니터링**
  - 메트릭 수집 (Prometheus)
  - 대시보드 구축 (Grafana)
  - 알림 시스템

- [ ] **로깅 시스템**
  - 구조화된 로깅
  - 중앙 집중식 로그 관리
  - 에러 추적 시스템

---

## 📋 11. 테스트 계획

### 단위 테스트
- [ ] Model 테스트
- [ ] Serializer 테스트  
- [ ] View 테스트
- [ ] Consumer 테스트

### 통합 테스트
- [ ] API 엔드포인트 테스트
- [ ] WebSocket 연결 테스트
- [ ] 이벤트 발행 테스트

### 성능 테스트
- [ ] 동시 접속자 테스트
- [ ] 메시지 처리량 테스트
- [ ] DB 쿼리 성능 테스트

---
